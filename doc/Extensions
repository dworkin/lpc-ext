			LPC extension interface

1. Introduction

DGD presents an interface for extending the driver with new kfuns and special
object types.  To enable this interface, DGD should be compiled with the macro
LPC_EXTENSION defined.  The driver will then call an external function at
initialization time:

    int lpc_ext_init(int major, int minor);

From this function, new kfuns may be added to the driver.  The interface
furthermore allows objects to be marked as `special'.

The extension code must be linked with DGD at compile time.  The include file
`lpc_ext.h' defines the entire interface with the driver, using macros that
all start with the prefix `LPC_'.  Compliant extensions should use these
macros, only.  Some of these macros will evaluate their arguments several
times; to be compatible with future releases, extensions should assume that
all LPC_* macros with arguments may do so.


2. Kernel functions

Kernel functions may be added during the initialization phase by calling the
following function:

    void lpc_ext_kfun(LPC_ext_kfun *kf, int n);

where `kf' is an array of LPC_ext_kfun structs, and `n' the number of elements
in that array.  lpc_ext_kfun() should be called only once, and must not
redeclare any existing kfuns.

The LPC_ext_kfun struct has the following fields:

    char *name;		/* kfun name */
    char *proto;	/* kfun prototype */
    func;		/* kfun function pointer */

Here `func' is a pointer to a C function with the following prototype:

    void func(LPC_frame f, int nargs, LPC_value retval);

Calls to the kfun with name `name' will be routed to that C function.  The
`f' argument contains the function context, `nargs' is the number of
arguments on the stack, and `retval' is a pointer to the return value.  The
function should not attempt to push or pop arguments; instead, arguments
should be accessed using the relevant lpc_frame_* macros listed below, and the
return value, if any, should be stored in the retval value using one of the
lpc_retval_* macros.  The default return value is nil.

Kfuns can call lpc_runtime_error() to indicate that an error occurred.  Errors
will interrupt the flow of execution, so lpc_runtime_error() is best called
before any LPC values are constructed or changed, including the return value of
the kfun.

Note that at present, the extension interface does not define a way to call an
LPC function from a kfun.

    LPC_object	  lpc_frame_object(LPC_frame f);	/* current object */
    LPC_dataspace lpc_frame_dataspace(LPC_frame f);	/* current dataspace */
    LPC_value	  lpc_frame_arg(LPC_frame f, int nargs, int n); /* argument n */
    int 	  lpc_frame_atomic(LPC_frame f);		/* atomic? */

    void	  lpc_runtime_error(LPC_frame f, char *error);

The `proto' field of the LPC_ext_kfun struct is a prototype for the function,
represented as a 0-terminated array of chars.  For example, the LPC prototypes

    string lower_case(string str);
    string concat(string str...);
    int foo(int *a, varargs object **b);
    void bar(void);
    void gnu();

would be represented as

    char lower_case_proto[] = { LPC_TYPE_STRING, LPC_TYPE_STRING, 0 };
    char concat_proto[] = { LPC_TYPE_STRING, LPC_TYPE_STRING,
			    LPC_TYPE_ELLIPSIS, 0 };
    char foo_proto[] = { LPC_TYPE_INT, LPC_TYPE_ARRAY_OF(LPC_TYPE_INT),
			 LPC_TYPE_VARARGS,
			 LPC_TYPE_ARRAY_OF(LPC_TYPE_ARRAY_OF(LPC_TYPE_OBJECT)),
			 0 };
    char bar_proto[] = { LPC_TYPE_VOID, LPC_TYPE_VOID, 0 };
    char gnu_proto[] = { LPC_TYPE_VOID, 0 };

Note that the prototypes of bar() and gnu() are effectively identical, just
as they would be for LPC functions; also note that varargs must be specified
in the new way, among the arguments of the prototype rather than in front of
the return type.

The building blocks for prototypes are:

    LPC_TYPE_VOID
    LPC_TYPE_INT
    LPC_TYPE_FLOAT
    LPC_TYPE_STRING
    LPC_TYPE_OBJECT
    LPC_TYPE_ARRAY_OF(lpc_type)
    LPC_TYPE_MAPPING
    LPC_TYPE_MIXED
    LPC_TYPE_VARARGS
    LPC_TYPE_ELLIPSIS


3. Special objects

DGD defines various types of special objects: user objects, editor objects
and parser objects.  Extensions may define their own additional special
object type.  Special objects have an additional LPC value.

Objects should only be marked as special if they are not special already.
If an object is to be unmarked, and a special LPC value has been set, it
should be reset to lpc_value_nil() first.

    int  lpc_object_isspecial(LPC_object obj);		/* special object */
    int  lpc_object_ismarked(LPC_object obj);		/* user-def special */
    void lpc_object_mark(LPC_object obj);		/* mark as special */
    void lpc_object_unmark(LPC_object obj);		/* unmark as special */

To retrieve or set the LPC value associated with a special object, the
following functions can be used.

    LPC_value	lpc_data_get_val(LPC_dataspace data);
    void	lpc_data_set_val(LPC_dataspace data, LPC_value val);


4. Operations on LPC values

The type of an LPC value can be determined with

    int lpc_value_type(LPC_value val);

The types can be:

    LPC_TYPE_NIL
    LPC_TYPE_INT
    LPC_TYPE_FLOAT
    LPC_TYPE_STRING
    LPC_TYPE_OBJECT
    LPC_TYPE_ARRAY
    LPC_TYPE_MAPPING
    LPC_TYPE_LWOBJ

Each type has its own set of macros.

    LPC_value	lpc_value_nil();	/* the nil value */

    LPC_int	lpc_int_getval(LPC_value val);
    void	lpc_int_putval(LPC_value val, LPC_int num);

    LPC_float	lpc_float_getval(LPC_value val);
    void	lpc_float_putval(LPC_value val, LPC_float flt);

    LPC_string	lpc_string_getval(LPC_value val);
    void	lpc_string_putval(LPC_value val, LPC_string str);
    LPC_string	lpc_string_new(LPC_dataspace data, char *text, int len);
    char       *lpc_string_text(LPC_string str);
    int		lpc_string_length(LPC_string str);

The current object may be stored as an array or mapping element.

    void	lpc_object_putval(LPC_value val, LPC_object obj);
    void	lpc_object_name(LPC_frame f, LPC_object obj, char *buffer);

Don't modify array elements directly, but use lpc_array_assign() to change
their value.

    LPC_array	lpc_array_getval(LPC_value val);
    void	lpc_array_putval(LPC_value val, LPC_array arr);
    LPC_array	lpc_array_new(LPC_dataspace data, int size);
    int		lpc_array_size(LPC_array arr);
    LPC_value	lpc_array_index(LPC_array arr, int i);
    void	lpc_array_assign(LPC_dataspace data, LPC_array arr, int index,
				 LPC_value val);

Don't modify mapping elements directly, but use lpc_mapping_assign() to change
their value.

    LPC_mapping	lpc_mapping_getval(LPC_value val);
    void	lpc_mapping_putval(LPC_value val, LPC_mapping map);
    LPC_mapping	lpc_mapping_new(LPC_dataspace data);
    int		lpc_mapping_size(LPC_array map);
    LPC_value	lpc_mapping_index(LPC_mapping map, LPC_value index);
    void	lpc_mapping_assign(LPC_dataspace data, LPC_mapping map,
				   LPC_value index, LPC_value val);
